{"version":3,"file":"Matches.js","sources":["../../src/Matches.tsx"],"sourcesContent":["import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { createControlledPromise, pick } from './utils'\nimport { CatchNotFound, DefaultGlobalNotFound, isNotFound } from './not-found'\nimport { isRedirect } from './redirects'\nimport { type AnyRouter, type RegisteredRouter } from './router'\nimport type { ResolveRelativePath, ToOptions } from './link'\nimport type { AnyRoute, ReactNode, StaticDataRouteOption } from './route'\nimport type {\n  AllParams,\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport type {\n  ControlledPromise,\n  DeepPartial,\n  Expand,\n  NoInfer,\n  StrictOrFrom,\n} from './utils'\n\nexport const matchContext = React.createContext<string | undefined>(undefined)\n\nexport interface RouteMatch<\n  TRouteId,\n  TAllParams,\n  TFullSearchSchema,\n  TLoaderData,\n  TAllContext,\n  TRouteContext,\n  TLoaderDeps,\n> {\n  id: string\n  routeId: TRouteId\n  pathname: string\n  params: TAllParams\n  status: 'pending' | 'success' | 'error' | 'redirected' | 'notFound'\n  isFetching: false | 'beforeLoad' | 'loader'\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loadPromise: ControlledPromise<void>\n  loaderPromise: Promise<TLoaderData>\n  loaderData?: TLoaderData\n  routeContext: TRouteContext\n  context: TAllContext\n  search: TFullSearchSchema\n  fetchCount: number\n  abortController: AbortController\n  cause: 'preload' | 'enter' | 'stay'\n  loaderDeps: TLoaderDeps\n  preload: boolean\n  invalid: boolean\n  meta?: Array<JSX.IntrinsicElements['meta']>\n  links?: Array<JSX.IntrinsicElements['link']>\n  scripts?: Array<JSX.IntrinsicElements['script']>\n  headers?: Record<string, string>\n  globalNotFound?: boolean\n  staticData: StaticDataRouteOption\n  minPendingPromise?: ControlledPromise<void>\n}\n\nexport type MakeRouteMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TTypes extends AnyRoute['types'] = RouteById<TRouteTree, TRouteId>['types'],\n  TAllParams = TReturnIntersection extends false\n    ? TTypes['allParams']\n    : Partial<AllParams<TRouteTree>>,\n  TFullSearchSchema = TReturnIntersection extends false\n    ? TTypes['fullSearchSchema']\n    : Partial<FullSearchSchema<TRouteTree>>,\n  TLoaderData = TTypes['loaderData'],\n  TAllContext = TTypes['allContext'],\n  TRouteContext = TTypes['routeContext'],\n  TLoaderDeps = TTypes['loaderDeps'],\n> = RouteMatch<\n  TRouteId,\n  TAllParams,\n  TFullSearchSchema,\n  TLoaderData,\n  TAllContext,\n  TRouteContext,\n  TLoaderDeps\n>\n\nexport type AnyRouteMatch = RouteMatch<any, any, any, any, any, any, any>\n\nexport function Matches() {\n  const router = useRouter()\n\n  const matchId = useRouterState({\n    select: (s) => {\n      return s.matches[0]?.id\n    },\n  })\n\n  const resetKey = useRouterState({\n    select: (s) => s.resolvedLocation.state.key!,\n  })\n\n  const inner = (\n    <matchContext.Provider value={matchId}>\n      <CatchBoundary\n        getResetKey={() => resetKey}\n        errorComponent={ErrorComponent}\n        onCatch={(error) => {\n          warning(\n            false,\n            `The following error wasn't caught by any route! ðŸ‘‡ At the very least, consider setting an 'errorComponent' in your RootRoute!`,\n          )\n          console.error(error)\n        }}\n      >\n        {matchId ? <Match matchId={matchId} /> : null}\n      </CatchBoundary>\n    </matchContext.Provider>\n  )\n\n  return router.options.InnerWrap ? (\n    <router.options.InnerWrap>{inner}</router.options.InnerWrap>\n  ) : (\n    inner\n  )\n}\n\nfunction SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n\nexport function Match({ matchId }: { matchId: string }) {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  invariant(\n    routeId,\n    `Could not find routeId for matchId \"${matchId}\". Please file an issue!`,\n  )\n\n  const route: AnyRoute = router.routesById[routeId]\n\n  const PendingComponent =\n    route.options.pendingComponent ?? router.options.defaultPendingComponent\n\n  const pendingElement = PendingComponent ? <PendingComponent /> : null\n\n  const routeErrorComponent =\n    route.options.errorComponent ?? router.options.defaultErrorComponent\n\n  const routeNotFoundComponent = route.isRoot\n    ? // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component\n      route.options.notFoundComponent ??\n      router.options.notFoundRoute?.options.component\n    : route.options.notFoundComponent\n\n  const ResolvedSuspenseBoundary =\n    route.options.wrapInSuspense ??\n    PendingComponent ??\n    route.options.component?.preload ??\n    route.options.pendingComponent?.preload ??\n    (route.options.errorComponent as any)?.preload\n      ? React.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = routeErrorComponent\n    ? CatchBoundary\n    : SafeFragment\n\n  const ResolvedNotFoundBoundary = routeNotFoundComponent\n    ? CatchNotFound\n    : SafeFragment\n\n  const resetKey = useRouterState({\n    select: (s) => s.resolvedLocation.state.key!,\n  })\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <ResolvedSuspenseBoundary fallback={pendingElement}>\n        <ResolvedCatchBoundary\n          getResetKey={() => resetKey}\n          errorComponent={routeErrorComponent ?? ErrorComponent}\n          onCatch={(error) => {\n            // Forward not found errors (we don't want to show the error component for these)\n            if (isNotFound(error)) throw error\n            warning(false, `Error in route match: ${matchId}`)\n            console.error(error)\n          }}\n        >\n          <ResolvedNotFoundBoundary\n            fallback={(error) => {\n              // If the current not found handler doesn't exist or it has a\n              // route ID which doesn't match the current route, rethrow the error\n              if (\n                !routeNotFoundComponent ||\n                (error.routeId && error.routeId !== routeId) ||\n                (!error.routeId && !route.isRoot)\n              )\n                throw error\n\n              return React.createElement(routeNotFoundComponent, error as any)\n            }}\n          >\n            <MatchInner matchId={matchId} />\n          </ResolvedNotFoundBoundary>\n        </ResolvedCatchBoundary>\n      </ResolvedSuspenseBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction MatchInner({\n  matchId,\n  // pendingElement,\n}: {\n  matchId: string\n  // pendingElement: any\n}): any {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const match = useRouterState({\n    select: (s) =>\n      pick(s.matches.find((d) => d.id === matchId)!, [\n        'id',\n        'status',\n        'error',\n        'loadPromise',\n        'minPendingPromise',\n      ]),\n  })\n\n  const RouteErrorComponent =\n    (route.options.errorComponent ?? router.options.defaultErrorComponent) ||\n    ErrorComponent\n\n  if (match.status === 'notFound') {\n    let error: unknown\n    if (isServerSideError(match.error)) {\n      const deserializeError =\n        router.options.errorSerializer?.deserialize ?? defaultDeserializeError\n\n      error = deserializeError(match.error.data)\n    } else {\n      error = match.error\n    }\n\n    invariant(isNotFound(error), 'Expected a notFound error')\n\n    return renderRouteNotFound(router, route, error)\n  }\n\n  if (match.status === 'redirected') {\n    // Redirects should be handled by the router transition. If we happen to\n    // encounter a redirect here, it's a bug. Let's warn, but render nothing.\n    invariant(isRedirect(match.error), 'Expected a redirect error')\n\n    // warning(\n    //   false,\n    //   'Tried to render a redirected route match! This is a weird circumstance, please file an issue!',\n    // )\n\n    throw match.loadPromise\n  }\n\n  if (match.status === 'error') {\n    // If we're on the server, we need to use React's new and super\n    // wonky api for throwing errors from a server side render inside\n    // of a suspense boundary. This is the only way to get\n    // renderToPipeableStream to not hang indefinitely.\n    // We'll serialize the error and rethrow it on the client.\n    if (router.isServer) {\n      return (\n        <RouteErrorComponent\n          error={match.error}\n          info={{\n            componentStack: '',\n          }}\n        />\n      )\n    }\n\n    if (isServerSideError(match.error)) {\n      const deserializeError =\n        router.options.errorSerializer?.deserialize ?? defaultDeserializeError\n      throw deserializeError(match.error.data)\n    } else {\n      throw match.error\n    }\n  }\n\n  if (match.status === 'pending') {\n    // We're pending, and if we have a minPendingMs, we need to wait for it\n    const pendingMinMs =\n      route.options.pendingMinMs ?? router.options.defaultPendingMinMs\n\n    if (pendingMinMs && !match.minPendingPromise) {\n      // Create a promise that will resolve after the minPendingMs\n\n      match.minPendingPromise = createControlledPromise()\n\n      if (!router.isServer) {\n        Promise.resolve().then(() => {\n          router.__store.setState((s) => ({\n            ...s,\n            matches: s.matches.map((d) =>\n              d.id === match.id\n                ? { ...d, minPendingPromise: createControlledPromise() }\n                : d,\n            ),\n          }))\n        })\n\n        setTimeout(() => {\n          // We've handled the minPendingPromise, so we can delete it\n          router.__store.setState((s) => {\n            return {\n              ...s,\n              matches: s.matches.map((d) =>\n                d.id === match.id\n                  ? {\n                      ...d,\n                      minPendingPromise:\n                        (d.minPendingPromise?.resolve(), undefined),\n                    }\n                  : d,\n              ),\n            }\n          })\n        }, pendingMinMs)\n      }\n    }\n\n    throw match.loadPromise\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (match.status === 'success') {\n    const Comp = route.options.component ?? router.options.defaultComponent\n\n    if (Comp) {\n      return <Comp />\n    }\n\n    return <Outlet />\n  }\n\n  invariant(\n    false,\n    'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n  )\n}\n\nexport const Outlet = React.memo(function Outlet() {\n  const router = useRouter()\n  const matchId = React.useContext(matchContext)\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const { parentGlobalNotFound } = useRouterState({\n    select: (s) => {\n      const matches = s.matches\n      const parentMatch = matches.find((d) => d.id === matchId)\n      invariant(\n        parentMatch,\n        `Could not find parent match for matchId \"${matchId}\"`,\n      )\n      return {\n        parentGlobalNotFound: parentMatch.globalNotFound,\n      }\n    },\n  })\n\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = s.matches\n      const index = matches.findIndex((d) => d.id === matchId)\n      return matches[index + 1]?.id\n    },\n  })\n\n  if (parentGlobalNotFound) {\n    return renderRouteNotFound(router, route, undefined)\n  }\n\n  if (!childMatchId) {\n    return null\n  }\n\n  return <Match matchId={childMatchId} />\n})\n\nfunction renderRouteNotFound(router: AnyRouter, route: AnyRoute, data: any) {\n  if (!route.options.notFoundComponent) {\n    if (router.options.defaultNotFoundComponent) {\n      return <router.options.defaultNotFoundComponent data={data} />\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      warning(\n        route.options.notFoundComponent,\n        `A notFoundError was encountered on the route with ID \"${route.id}\", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<div>Not Found<div>)`,\n      )\n    }\n\n    return <DefaultGlobalNotFound />\n  }\n\n  return <route.options.notFoundComponent data={data} />\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\nexport type UseMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> = RoutePaths<\n    TRouter['routeTree']\n  >,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom,\n  TMaskTo extends string = '',\n  TOptions extends ToOptions<\n    TRouter,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  > = ToOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n  TRelaxedOptions = Omit<TOptions, 'search' | 'params'> &\n    DeepPartial<Pick<TOptions, 'search' | 'params'>>,\n> = TRelaxedOptions & MatchRouteOptions\n\nexport function useMatchRoute<TRouter extends AnyRouter = RegisteredRouter>() {\n  const router = useRouter()\n\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n      TMaskTo extends string = '',\n      TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n    >(\n      opts: UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ):\n      | false\n      | RouteById<TRouter['routeTree'], TResolved>['types']['allParams'] => {\n      const { pending, caseSensitive, fuzzy, includeSearch, ...rest } = opts\n\n      return router.matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n        fuzzy,\n        includeSearch,\n      })\n    },\n    [router],\n  )\n}\n\nexport type MakeMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> = RoutePaths<\n    TRouter['routeTree']\n  >,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom,\n  TMaskTo extends string = '',\n> = UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | ((\n        params?: RouteByPath<\n          TRouter['routeTree'],\n          ResolveRelativePath<TFrom, NoInfer<TTo>>\n        >['types']['allParams'],\n      ) => ReactNode)\n    | React.ReactNode\n}\n\nexport function MatchRoute<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> = RoutePaths<\n    TRouter['routeTree']\n  >,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom,\n  TMaskTo extends string = '',\n>(props: MakeMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props as any)\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return params ? props.children : null\n}\n\nexport function useMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = MakeRouteMatch<TRouteTree, TFrom, TReturnIntersection>,\n  TSelected = TRouteMatch,\n>(\n  opts: StrictOrFrom<TFrom, TReturnIntersection> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TSelected {\n  const nearestMatchId = React.useContext(matchContext)\n\n  const matchSelection = useRouterState({\n    select: (state) => {\n      const match = state.matches.find((d) =>\n        opts.from ? opts.from === d.routeId : d.id === nearestMatchId,\n      )\n\n      invariant(\n        match,\n        `Could not find ${\n          opts.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'\n        }`,\n      )\n\n      return opts.select ? opts.select(match as any) : match\n    },\n  })\n\n  return matchSelection as TSelected\n}\n\nexport function useMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = MakeRouteMatch<TRouteTree, TRouteId, TReturnIntersection>,\n  T = Array<TRouteMatch>,\n>(opts?: {\n  select?: (matches: Array<TRouteMatch>) => T\n  experimental_returnIntersection?: TReturnIntersection\n}): T {\n  return useRouterState({\n    select: (state) => {\n      const matches = state.matches\n      return opts?.select\n        ? opts.select(matches as Array<TRouteMatch>)\n        : (matches as T)\n    },\n  })\n}\n\nexport function useParentMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = MakeRouteMatch<TRouteTree, TRouteId, TReturnIntersection>,\n  T = Array<TRouteMatch>,\n>(opts?: {\n  select?: (matches: Array<TRouteMatch>) => T\n  experimental_returnIntersection?: TReturnIntersection\n}): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        0,\n        matches.findIndex((d) => d.id === contextMatchId),\n      )\n      return opts?.select\n        ? opts.select(matches as Array<TRouteMatch>)\n        : (matches as T)\n    },\n  })\n}\n\nexport function useChildMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = MakeRouteMatch<TRouteTree, TRouteId, TReturnIntersection>,\n  T = Array<TRouteMatch>,\n>(opts?: {\n  select?: (matches: Array<TRouteMatch>) => T\n  experimental_returnIntersection?: TReturnIntersection\n}): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        matches.findIndex((d) => d.id === contextMatchId) + 1,\n      )\n      return opts?.select\n        ? opts.select(matches as Array<TRouteMatch>)\n        : (matches as T)\n    },\n  })\n}\n\nexport function useLoaderDeps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TRouteMatch extends MakeRouteMatch<TRouteTree, TFrom> = MakeRouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderDeps'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TSelected {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s.loaderDeps)\n        : s.loaderDeps\n    },\n  })\n}\n\nexport function useLoaderData<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TRouteMatch extends MakeRouteMatch<TRouteTree, TFrom> = MakeRouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderData'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TSelected {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s.loaderData as TRouteMatch)\n        : s.loaderData\n    },\n  }) as TSelected\n}\n\nexport function isServerSideError(error: unknown): error is {\n  __isServerError: true\n  data: Record<string, any>\n} {\n  if (!(typeof error === 'object' && error && 'data' in error)) return false\n  if (!('__isServerError' in error && error.__isServerError)) return false\n  if (!(typeof error.data === 'object' && error.data)) return false\n\n  return error.__isServerError === true\n}\n\nexport function defaultDeserializeError(serializedData: Record<string, any>) {\n  if ('name' in serializedData && 'message' in serializedData) {\n    const error = new Error(serializedData.message)\n    error.name = serializedData.name\n    if (process.env.NODE_ENV === 'development') {\n      error.stack = serializedData.stack\n    }\n    return error\n  }\n\n  return serializedData.data\n}\n"],"names":["_a","Outlet"],"mappings":"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"}