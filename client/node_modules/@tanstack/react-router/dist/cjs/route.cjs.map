{"version":3,"file":"route.cjs","sources":["../../src/route.ts"],"sourcesContent":["import invariant from 'tiny-invariant'\nimport { useLoaderData, useLoaderDeps, useMatch } from './Matches'\nimport { joinPaths, trimPathLeft } from './path'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport { notFound } from './not-found'\nimport { useNavigate } from './useNavigate'\nimport type { UseNavigateResult } from './useNavigate'\nimport type * as React from 'react'\nimport type { MakeRouteMatch, RouteMatch } from './Matches'\nimport type { NavigateOptions, ParsePathParams, ToSubOptions } from './link'\nimport type { ParsedLocation } from './location'\nimport type { RouteById, RouteIds, RoutePaths } from './routeInfo'\nimport type { AnyRouter, RegisteredRouter, Router } from './router'\nimport type {\n  Assign,\n  Expand,\n  IsAny,\n  NoInfer,\n  PickRequired,\n  UnionToIntersection,\n} from './utils'\nimport type { BuildLocationFn, NavigateFn } from './RouterProvider'\nimport type { NotFoundError } from './not-found'\nimport type { LazyRoute } from './fileRoute'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\n\nexport type SearchSchemaInput = {\n  __TSearchSchemaInput__: 'TSearchSchemaInput'\n}\n\nexport type AnySearchSchema = {}\n\nexport type AnyContext = {}\n\nexport interface RouteContext {}\n\nexport type PreloadableObj = { preload?: () => Promise<void> }\n\nexport type RoutePathOptions<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport interface StaticDataRouteOption {}\n\nexport type RoutePathOptionsIntersection<TCustomId, TPath> =\n  UnionToIntersection<RoutePathOptions<TCustomId, TPath>>\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchemaInput extends Record<string, any> = {},\n  TSearchSchema extends Record<string, any> = {},\n  TSearchSchemaUsed = {},\n  TFullSearchSchemaInput = TSearchSchemaUsed,\n  TFullSearchSchema = TSearchSchema,\n  TParams = AnyPathParams,\n  TAllParams = TParams,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext = RouteContext,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TAllContext = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n  TLoaderData = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n> = BaseRouteOptions<\n  TParentRoute,\n  TCustomId,\n  TPath,\n  TSearchSchemaInput,\n  TSearchSchema,\n  TSearchSchemaUsed,\n  TFullSearchSchemaInput,\n  TFullSearchSchema,\n  TParams,\n  TAllParams,\n  TRouteContextReturn,\n  TRouteContext,\n  TRouterContext,\n  TAllContext,\n  TLoaderDeps,\n  TLoaderDataReturn\n> &\n  UpdatableRouteOptions<\n    NoInfer<TCustomId>,\n    NoInfer<TAllParams>,\n    NoInfer<TFullSearchSchema>,\n    NoInfer<TLoaderData>,\n    NoInfer<TAllContext>,\n    NoInfer<TRouteContext>,\n    NoInfer<TLoaderDeps>\n  >\n\nexport type ParamsFallback<\n  TPath extends string,\n  TParams,\n> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams\n\nexport type FileBaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TPath extends string = string,\n  TSearchSchemaInput extends Record<string, any> = {},\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema = TSearchSchema,\n  TParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext = RouteContext,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TAllContext = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n> = {\n  validateSearch?: SearchSchemaValidator<TSearchSchemaInput, TSearchSchema>\n  shouldReload?:\n    | boolean\n    | ((\n        match: LoaderFnContext<\n          TAllParams,\n          TFullSearchSchema,\n          TAllContext,\n          TRouteContext\n        >,\n      ) => any)\n  // This async function is called before a route is loaded.\n  // If an error is thrown here, the route's loader will not be called.\n  // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n  // If thrown during a preload event, the error will be logged to the console.\n  beforeLoad?: BeforeLoadFn<\n    TFullSearchSchema,\n    TParentRoute,\n    TAllParams,\n    TRouteContextReturn,\n    TRouterContext\n  >\n  loaderDeps?: (opts: { search: TFullSearchSchema }) => TLoaderDeps\n  loader?: RouteLoaderFn<\n    TAllParams,\n    NoInfer<TLoaderDeps>,\n    NoInfer<TAllContext>,\n    NoInfer<TRouteContext>,\n    TLoaderDataReturn\n  >\n} & (\n  | {\n      // Both or none\n      parseParams?: (\n        rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n      ) => TParams extends Record<ParsePathParams<TPath>, any>\n        ? TParams\n        : 'parseParams must return an object'\n      stringifyParams?: (\n        params: NoInfer<ParamsFallback<TPath, TParams>>,\n      ) => Record<ParsePathParams<TPath>, string>\n    }\n  | {\n      stringifyParams?: never\n      parseParams?: never\n    }\n)\n\nexport type BaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchemaInput extends Record<string, any> = {},\n  TSearchSchema extends Record<string, any> = {},\n  TSearchSchemaUsed = {},\n  TFullSearchSchemaInput = TSearchSchemaUsed,\n  TFullSearchSchema = TSearchSchema,\n  TParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext = RouteContext,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TAllContext = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n> = RoutePathOptions<TCustomId, TPath> &\n  FileBaseRouteOptions<\n    TParentRoute,\n    TPath,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn\n  > & {\n    getParentRoute: () => TParentRoute\n  }\n\ntype BeforeLoadFn<\n  in out TFullSearchSchema,\n  in out TParentRoute extends AnyRoute,\n  in out TAllParams,\n  TRouteContextReturn extends RouteContext,\n  in out TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  in out TContext = IsAny<TParentRoute['types']['allContext'], TRouterContext>,\n> = (opts: {\n  search: TFullSearchSchema\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  context: TContext\n  location: ParsedLocation\n  navigate: NavigateFn\n  buildLocation: BuildLocationFn<TParentRoute>\n  cause: 'preload' | 'enter' | 'stay'\n}) => Promise<TRouteContextReturn> | TRouteContextReturn | void\n\nexport type UpdatableRouteOptions<\n  TRouteId,\n  TAllParams,\n  TFullSearchSchema,\n  TLoaderData,\n  TAllContext,\n  TRouteContext,\n  TLoaderDeps,\n  TRouteMatch = RouteMatch<\n    TRouteId,\n    TAllParams,\n    TFullSearchSchema,\n    TLoaderData,\n    TAllContext,\n    TRouteContext,\n    TLoaderDeps\n  >,\n> = {\n  // test?: (args: TAllContext) => void\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent\n  errorComponent?: false | null | ErrorRouteComponent\n  notFoundComponent?: NotFoundRouteComponent\n  pendingComponent?: RouteComponent\n  pendingMs?: number\n  pendingMinMs?: number\n  staleTime?: number\n  gcTime?: number\n  preloadStaleTime?: number\n  preloadGcTime?: number\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: Array<SearchFilter<TFullSearchSchema>>\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: Array<SearchFilter<TFullSearchSchema>>\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (match: TRouteMatch) => void\n  onStay?: (match: TRouteMatch) => void\n  onLeave?: (match: TRouteMatch) => void\n  meta?: (ctx: {\n    params: TAllParams\n    loaderData: TLoaderData\n  }) => Array<JSX.IntrinsicElements['meta']>\n  links?: () => Array<JSX.IntrinsicElements['link']>\n  scripts?: () => Array<JSX.IntrinsicElements['script']>\n  headers?: (ctx: { loaderData: TLoaderData }) => Record<string, string>\n} & UpdatableStaticRouteOption\n\nexport type UpdatableStaticRouteOption =\n  {} extends PickRequired<StaticDataRouteOption>\n    ? {\n        staticData?: StaticDataRouteOption\n      }\n    : {\n        staticData: StaticDataRouteOption\n      }\n\nexport type MetaDescriptor =\n  | { charSet: 'utf-8' }\n  | { title: string }\n  | { name: string; content: string }\n  | { property: string; content: string }\n  | { httpEquiv: string; content: string }\n  | { 'script:ld+json': LdJsonObject }\n  | { tagName: 'meta' | 'link'; [name: string]: string }\n  | Record<string, unknown>\n\ntype LdJsonObject = { [Key in string]: LdJsonValue } & {\n  [Key in string]?: LdJsonValue | undefined\n}\ntype LdJsonArray = Array<LdJsonValue> | ReadonlyArray<LdJsonValue>\ntype LdJsonPrimitive = string | number | boolean | null\ntype LdJsonValue = LdJsonPrimitive | LdJsonObject | LdJsonArray\n\nexport type RouteLinkEntry = {}\n\nexport type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<\n  TPath,\n  TParams\n>\n\nexport type ParseParamsFn<TPath extends string, TParams> = (\n  rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n) => TParams extends Record<ParsePathParams<TPath>, any>\n  ? TParams\n  : 'parseParams must return an object'\n\nexport type ParseParamsObj<TPath extends string, TParams> = {\n  parse?: ParseParamsFn<TPath, TParams>\n}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TInput, TReturn> =\n  | SearchSchemaValidatorObj<TInput, TReturn>\n  | SearchSchemaValidatorFn<TInput, TReturn>\n\nexport type SearchSchemaValidatorObj<TInput, TReturn> = {\n  parse?: SearchSchemaValidatorFn<TInput, TReturn>\n}\n\nexport type SearchSchemaValidatorFn<TInput, TReturn> = (\n  searchObj: TInput,\n) => TReturn\n\nexport type RouteLoaderFn<\n  in out TAllParams = {},\n  in out TLoaderDeps extends Record<string, any> = {},\n  in out TAllContext = AnyContext,\n  in out TRouteContext = AnyContext,\n  TLoaderData = unknown,\n> = (\n  match: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext, TRouteContext>,\n) => Promise<TLoaderData> | TLoaderData\n\nexport interface LoaderFnContext<\n  in out TAllParams = {},\n  in out TLoaderDeps = {},\n  in out TAllContext = AnyContext,\n  in out TRouteContext = AnyContext,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  deps: TLoaderDeps\n  context: Assign<TAllContext, TRouteContext>\n  location: ParsedLocation // Do not supply search schema here so as to demotivate people from trying to shortcut loaderDeps\n  /**\n   * @deprecated Use `throw redirect({ to: '/somewhere' })` instead\n   **/\n  navigate: (opts: NavigateOptions<AnyRouter>) => Promise<void>\n  parentMatchPromise?: Promise<void>\n  cause: 'preload' | 'enter' | 'stay'\n  route: Route\n}\n\nexport type SearchFilter<TInput, TResult = TInput> = (prev: TInput) => TResult\n\nexport type ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchema: infer TFullSearchSchema\n  }\n}\n  ? TFullSearchSchema\n  : {}\n\nexport type InferFullSearchSchemaInput<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchemaInput: infer TFullSearchSchemaInput\n  }\n}\n  ? TFullSearchSchemaInput\n  : {}\n\nexport type ResolveFullSearchSchema<\n  TParentRoute extends AnyRoute,\n  TSearchSchema,\n> = Assign<\n  TParentRoute['id'] extends RootRouteId\n    ? Omit<TParentRoute['types']['searchSchema'], keyof RootSearchSchema>\n    : TParentRoute['types']['fullSearchSchema'],\n  TSearchSchema\n>\n\nexport type ResolveFullSearchSchemaInput<\n  TParentRoute extends AnyRoute,\n  TSearchSchemaUsed,\n> = Assign<\n  TParentRoute['id'] extends RootRouteId\n    ? Omit<TParentRoute['types']['searchSchemaInput'], keyof RootSearchSchema>\n    : TParentRoute['types']['fullSearchSchemaInput'],\n  TSearchSchemaUsed\n>\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport type MergeFromFromParent<T, U> = IsAny<T, U, T & U>\n\nexport type ResolveAllParams<TParentRoute extends AnyRoute, TParams> =\n  Record<never, string> extends TParentRoute['types']['allParams']\n    ? TParams\n    : UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySearchSchema\n  TFullSearchSchema: AnySearchSchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport function getRouteApi<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>,\n  TFullSearchSchema = TRoute['types']['fullSearchSchema'],\n  TAllParams = TRoute['types']['allParams'],\n  TAllContext = TRoute['types']['allContext'],\n  TLoaderDeps = TRoute['types']['loaderDeps'],\n  TLoaderData = TRoute['types']['loaderData'],\n>(id: TId) {\n  return new RouteApi<\n    TId,\n    TRoute,\n    TFullSearchSchema,\n    TAllParams,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderData\n  >({ id })\n}\n\nexport class RouteApi<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>,\n  TFullSearchSchema = TRoute['types']['fullSearchSchema'],\n  TAllParams = TRoute['types']['allParams'],\n  TAllContext = TRoute['types']['allContext'],\n  TLoaderDeps = TRoute['types']['loaderDeps'],\n  TLoaderData = TRoute['types']['loaderData'],\n> {\n  id: TId\n\n  /**\n   * @deprecated Use the `getRouteApi` function instead.\n   */\n  constructor({ id }: { id: TId }) {\n    this.id = id as any\n  }\n\n  useMatch = <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TRouteMatch = MakeRouteMatch<TRouteTree, TId>,\n    TSelected = TRouteMatch,\n  >(opts?: {\n    select?: (match: TRouteMatch) => TSelected\n  }): TSelected => {\n    return useMatch({ select: opts?.select, from: this.id })\n  }\n\n  useRouteContext = <TSelected = Expand<TAllContext>>(opts?: {\n    select?: (s: Expand<TAllContext>) => TSelected\n  }): TSelected => {\n    return useMatch({\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    })\n  }\n\n  useSearch = <TSelected = Expand<TFullSearchSchema>>(opts?: {\n    select?: (s: Expand<TFullSearchSchema>) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id })\n  }\n\n  useParams = <TSelected = Expand<TAllParams>>(opts?: {\n    select?: (s: Expand<TAllParams>) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id })\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id, strict: false } as any)\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (s: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id, strict: false } as any)\n  }\n\n  useNavigate = () => {\n    return useNavigate({ from: this.id })\n  }\n\n  notFound = (opts?: NotFoundError) => {\n    return notFound({ routeId: this.id as string, ...opts })\n  }\n}\n\nexport class Route<\n  in out TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  in out TPath extends RouteConstraints['TPath'] = '/',\n  in out TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  in out TCustomId extends RouteConstraints['TCustomId'] = string,\n  in out TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  in out TSearchSchemaInput extends RouteConstraints['TSearchSchema'] = {},\n  in out TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  in out TSearchSchemaUsed = TSearchSchemaInput extends SearchSchemaInput\n    ? Omit<TSearchSchemaInput, keyof SearchSchemaInput>\n    : TSearchSchema,\n  in out TFullSearchSchemaInput = ResolveFullSearchSchemaInput<\n    TParentRoute,\n    TSearchSchemaUsed\n  >,\n  in out TFullSearchSchema = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  in out TParams = Record<ParsePathParams<TPath>, string>,\n  in out TAllParams = ResolveAllParams<TParentRoute, TParams>,\n  TRouteContextReturn extends RouteConstraints['TRouteContext'] = RouteContext,\n  in out TRouteContext = [TRouteContextReturn] extends [never]\n    ? RouteContext\n    : TRouteContextReturn,\n  in out TAllContext = Assign<\n    IsAny<TParentRoute['types']['allContext'], {}>,\n    TRouteContext\n  >,\n  in out TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  in out TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n  in out TLoaderData = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n  in out TChildren extends RouteConstraints['TChildren'] = unknown,\n> {\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: AnyRouter\n  rank!: number\n  lazyFn?: () => Promise<LazyRoute<any>>\n\n  /**\n   * @deprecated Use the `createRoute` function instead.\n   */\n  constructor(\n    options?: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchemaInput,\n      TSearchSchema,\n      TSearchSchemaUsed,\n      TFullSearchSchemaInput,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContextReturn,\n      TRouteContext,\n      TRouterContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderDataReturn,\n      TLoaderData\n    >,\n  ) {\n    this.options = (options as any) || {}\n\n    this.isRoot = !options?.getParentRoute as any\n    invariant(\n      !((options as any)?.id && (options as any)?.path),\n      `Route cannot have both an 'id' and a 'path' option.`,\n    )\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    searchSchemaInput: TSearchSchemaInput\n    searchSchemaUsed: TSearchSchemaUsed\n    fullSearchSchema: TFullSearchSchema\n    fullSearchSchemaInput: TFullSearchSchemaInput\n    params: TParams\n    allParams: TAllParams\n    routeContext: TRouteContext\n    allContext: TAllContext\n    children: TChildren\n    routerContext: TRouterContext\n    loaderData: TLoaderData\n    loaderDeps: TLoaderDeps\n  }\n\n  init = (opts: { originalIndex: number }): void => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as\n      | (RouteOptions<\n          TParentRoute,\n          TCustomId,\n          TPath,\n          TSearchSchemaInput,\n          TSearchSchema,\n          TSearchSchemaUsed,\n          TFullSearchSchemaInput,\n          TFullSearchSchema,\n          TParams,\n          TAllParams,\n          TRouteContextReturn,\n          TRouteContext,\n          TRouterContext,\n          TAllContext,\n          TLoaderDeps,\n          TLoaderDataReturn,\n          TLoaderData\n        > &\n          RoutePathOptionsIntersection<TCustomId, TPath>)\n      | undefined\n\n    const isRoot = !options?.path && !options?.id\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPathLeft(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren = <const TNewChildren extends ReadonlyArray<AnyRoute>>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData,\n    TNewChildren\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  updateLoader = <TNewLoaderData = unknown>(options: {\n    loader: RouteLoaderFn<\n      TAllParams,\n      TLoaderDeps,\n      TAllContext,\n      TRouteContext,\n      TNewLoaderData\n    >\n  }) => {\n    Object.assign(this.options, options)\n    return this as unknown as Route<\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TSearchSchemaInput,\n      TSearchSchema,\n      TSearchSchemaUsed,\n      TFullSearchSchemaInput,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContextReturn,\n      TRouteContext,\n      TAllContext,\n      TRouterContext,\n      TLoaderDeps,\n      TNewLoaderData,\n      TChildren\n    >\n  }\n\n  update = (\n    options: UpdatableRouteOptions<\n      TCustomId,\n      TAllParams,\n      TFullSearchSchema,\n      TLoaderData,\n      TAllContext,\n      TRouteContext,\n      TLoaderDeps\n    >,\n  ): this => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  lazy = (lazyFn: () => Promise<LazyRoute<any>>): this => {\n    this.lazyFn = lazyFn\n    return this\n  }\n\n  useMatch = <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TRouteMatch = MakeRouteMatch<TRouteTree, TId>,\n    TSelected = TRouteMatch,\n  >(opts?: {\n    select?: (match: TRouteMatch) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id })\n  }\n\n  useRouteContext = <TSelected = Expand<TAllContext>>(opts?: {\n    select?: (search: Expand<TAllContext>) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    })\n  }\n\n  useSearch = <TSelected = Expand<TFullSearchSchema>>(opts?: {\n    select?: (search: Expand<TFullSearchSchema>) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id })\n  }\n\n  useParams = <TSelected = Expand<TAllParams>>(opts?: {\n    select?: (search: Expand<TAllParams>) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id })\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (search: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any)\n  }\n\n  useNavigate = (): UseNavigateResult<string> => {\n    return useNavigate({ from: this.id })\n  }\n}\n\nexport function createRoute<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchemaInput extends RouteConstraints['TSearchSchema'] = {},\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TSearchSchemaUsed = TSearchSchemaInput extends SearchSchemaInput\n    ? Omit<TSearchSchemaInput, keyof SearchSchemaInput>\n    : TSearchSchema,\n  TFullSearchSchemaInput = ResolveFullSearchSchemaInput<\n    TParentRoute,\n    TSearchSchemaUsed\n  >,\n  TFullSearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>,\n  TParams = Record<ParsePathParams<TPath>, string>,\n  TAllParams = ResolveAllParams<TParentRoute, TParams>,\n  TRouteContextReturn extends RouteConstraints['TRouteContext'] = RouteContext,\n  TRouteContext = [TRouteContextReturn] extends [never]\n    ? RouteContext\n    : TRouteContextReturn,\n  TAllContext = Assign<\n    IsAny<TParentRoute['types']['allContext'], {}>,\n    TRouteContext\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n  TLoaderData = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n>(\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData\n  >,\n) {\n  return new Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData,\n    TChildren\n  >(options)\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any, any, any, any, any>\n\nexport function createRootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TSearchSchemaInput extends Record<string, any> = RootSearchSchema,\n    TSearchSchema extends Record<string, any> = RootSearchSchema,\n    TSearchSchemaUsed extends Record<string, any> = RootSearchSchema,\n    TRouteContextReturn extends RouteContext = RouteContext,\n    TRouteContext extends RouteContext = [TRouteContextReturn] extends [never]\n      ? RouteContext\n      : TRouteContextReturn,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderDataReturn = unknown,\n    TLoaderData = [TLoaderDataReturn] extends [never]\n      ? undefined\n      : TLoaderDataReturn,\n  >(\n    options?: Omit<\n      RouteOptions<\n        any, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchemaInput, // TSearchSchemaInput\n        TSearchSchema, // TSearchSchema\n        TSearchSchemaUsed,\n        TSearchSchemaUsed, //TFullSearchSchemaInput\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContextReturn, // TRouteContextReturn\n        TRouteContext, // TRouteContext\n        TRouterContext,\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderDataReturn, // TLoaderDataReturn,\n        TLoaderData // TLoaderData,\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) => {\n    return createRootRoute<\n      TSearchSchemaInput,\n      TSearchSchema,\n      TSearchSchemaUsed,\n      TRouteContextReturn,\n      TRouteContext,\n      TRouterContext,\n      TLoaderDeps,\n      TLoaderData\n    >(options as any)\n  }\n}\n\n/**\n * @deprecated Use the `createRootRouteWithContext` function instead.\n */\nexport const rootRouteWithContext = createRootRouteWithContext\n\nexport type RootSearchSchema = {\n  __TRootSearchSchema__: '__TRootSearchSchema__'\n}\n\nexport class RootRoute<\n  in out TSearchSchemaInput extends Record<string, any> = RootSearchSchema,\n  in out TSearchSchema extends Record<string, any> = RootSearchSchema,\n  in out TSearchSchemaUsed extends Record<string, any> = RootSearchSchema,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  in out TRouteContext extends RouteContext = [TRouteContextReturn] extends [\n    never,\n  ]\n    ? RouteContext\n    : TRouteContextReturn,\n  in out TRouterContext extends {} = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n  in out TLoaderData = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n> extends Route<\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchSchemaInput, // TSearchSchemaInput\n  TSearchSchema, // TSearchSchema\n  TSearchSchemaUsed,\n  TSearchSchemaUsed, // TFullSearchSchemaInput\n  TSearchSchema, // TFullSearchSchema\n  {}, // TParams\n  {}, // TAllParams\n  TRouteContextReturn, // TRouteContextReturn\n  TRouteContext, // TRouteContext\n  Assign<TRouterContext, TRouteContext>, // TAllContext\n  TRouterContext, // TRouterContext\n  TLoaderDeps,\n  TLoaderDataReturn,\n  TLoaderData,\n  any // TChildren\n> {\n  /**\n   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n   */\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        any, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchemaInput, // TSearchSchemaInput\n        TSearchSchema, // TSearchSchema\n        TSearchSchemaUsed,\n        TSearchSchemaUsed, // TFullSearchSchemaInput\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContextReturn, // TRouteContextReturn\n        TRouteContext, // TRouteContext\n        TRouterContext,\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderDataReturn,\n        TLoaderData\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n}\n\nexport function createRootRoute<\n  TSearchSchemaInput extends Record<string, any> = RootSearchSchema,\n  TSearchSchema extends Record<string, any> = RootSearchSchema,\n  TSearchSchemaUsed extends Record<string, any> = RootSearchSchema,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext extends RouteContext = [TRouteContextReturn] extends [never]\n    ? RouteContext\n    : TRouteContextReturn,\n  TRouterContext extends {} = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n  TLoaderData = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n>(\n  options?: Omit<\n    RouteOptions<\n      any, // TParentRoute\n      RootRouteId, // TCustomId\n      '', // TPath\n      TSearchSchemaInput, // TSearchSchemaInput\n      TSearchSchema, // TSearchSchema\n      TSearchSchemaUsed,\n      TSearchSchemaUsed, // TFullSearchSchemaInput\n      TSearchSchema, // TFullSearchSchema\n      {}, // TParams\n      {}, // TAllParams\n      TRouteContextReturn, // TRouteContextReturn\n      TRouteContext, // TRouteContext\n      TRouterContext,\n      Assign<TRouterContext, TRouteContext>, // TAllContext\n      TLoaderDeps,\n      TLoaderDataReturn,\n      TLoaderData\n    >,\n    | 'path'\n    | 'id'\n    | 'getParentRoute'\n    | 'caseSensitive'\n    | 'parseParams'\n    | 'stringifyParams'\n  >,\n) {\n  return new RootRoute<\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData\n  >(options)\n}\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n    ? TPrefix extends RootRouteId\n      ? TPath extends '/'\n        ? '/'\n        : `/${TrimPath<TPath>}`\n      : `${TPrefix}/${TPath}` extends '/'\n        ? '/'\n        : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n    : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n      ? TrimPathLeft<U>\n      : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n    ? TrimPathRight<U>\n    : T\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree>,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToSubOptions<Router<TRouteTree, 'never'>, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\n/**\n * @deprecated Use `ErrorComponentProps` instead.\n */\nexport type ErrorRouteProps = {\n  error: unknown\n  info?: { componentStack: string }\n  reset: () => void\n}\n\nexport type ErrorComponentProps = {\n  error: unknown\n  info?: { componentStack: string }\n  reset: () => void\n}\nexport type NotFoundRouteProps = {\n  // TODO: Make sure this is `| null | undefined` (this is for global not-founds)\n  data: unknown\n}\n//\n\nexport type ReactNode = any\n\nexport type SyncRouteComponent<TProps> =\n  | ((props: TProps) => ReactNode)\n  | React.LazyExoticComponent<(props: TProps) => ReactNode>\n\nexport type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent<TProps = any> = SyncRouteComponent<TProps> &\n  AsyncRouteComponent<TProps>\n\nexport type ErrorRouteComponent = RouteComponent<ErrorComponentProps>\n\nexport type NotFoundRouteComponent = SyncRouteComponent<NotFoundRouteProps>\n\nexport class NotFoundRoute<\n  TParentRoute extends AnyRootRoute,\n  TSearchSchemaInput extends Record<string, any> = {},\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TSearchSchemaUsed extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchemaInput extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchemaInput<\n    TParentRoute,\n    TSearchSchemaUsed\n  >,\n  TFullSearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>,\n  TRouteContextReturn extends RouteConstraints['TRouteContext'] = AnyContext,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext = Assign<\n    IsAny<TParentRoute['types']['allContext'], {}>,\n    TRouteContext\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n  TLoaderData = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n> extends Route<\n  TParentRoute,\n  '/404',\n  '/404',\n  '404',\n  '404',\n  TSearchSchemaInput,\n  TSearchSchema,\n  TSearchSchemaUsed,\n  TFullSearchSchemaInput,\n  TFullSearchSchema,\n  {},\n  {},\n  TRouteContextReturn,\n  TRouteContext,\n  TAllContext,\n  TRouterContext,\n  TLoaderDeps,\n  TLoaderDataReturn,\n  TLoaderData,\n  TChildren\n> {\n  constructor(\n    options: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        string,\n        TSearchSchemaInput,\n        TSearchSchema,\n        TSearchSchemaUsed,\n        TFullSearchSchemaInput,\n        TFullSearchSchema,\n        {},\n        {},\n        TRouteContextReturn,\n        TRouteContext,\n        TRouterContext,\n        TAllContext,\n        TLoaderDeps,\n        TLoaderDataReturn,\n        TLoaderData\n      >,\n      'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id'\n    >,\n  ) {\n    super({\n      ...(options as any),\n      id: '404',\n    })\n  }\n}\n"],"names":["useMatch","useSearch","useParams","useLoaderDeps","useLoaderData","useNavigate","notFound","options","path","trimPathLeft","joinPaths"],"mappings":"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"}